# Optimize GEMM step by step


## Result

### MMult0.c

40 6.141563e-01 0.000000e+00
80 5.996341e-01 0.000000e+00
120 5.949347e-01 0.000000e+00
160 5.867897e-01 0.000000e+00
200 5.897105e-01 0.000000e+00
240 5.888551e-01 0.000000e+00
280 5.878294e-01 0.000000e+00
320 5.834000e-01 0.000000e+00
360 5.859244e-01 0.000000e+00
400 5.869953e-01 0.000000e+00
440 5.847044e-01 0.000000e+00
480 5.841649e-01 0.000000e+00

### MMult1.c
将最内层循环写成一个子函数

40 7.063706e-01 0.000000e+00
80 6.398668e-01 0.000000e+00
120 6.211964e-01 0.000000e+00
160 6.087576e-01 0.000000e+00
200 6.046901e-01 0.000000e+00
240 6.028132e-01 0.000000e+00
280 5.998736e-01 0.000000e+00
320 5.843010e-01 0.000000e+00
360 5.959986e-01 0.000000e+00
400 5.948869e-01 0.000000e+00
440 5.930018e-01 0.000000e+00
480 5.902639e-01 0.000000e+00

### MMult2.c
最内存循环写成一个子函数，并且一次计算四行一列

40 6.994536e-01 0.000000e+00
80 6.418723e-01 0.000000e+00
120 6.195769e-01 0.000000e+00
160 6.095786e-01 0.000000e+00
200 6.047892e-01 0.000000e+00
240 6.031545e-01 0.000000e+00
280 6.005458e-01 0.000000e+00
320 5.917278e-01 0.000000e+00
360 5.961168e-01 0.000000e+00
400 5.922830e-01 0.000000e+00
440 5.918232e-01 0.000000e+00
480 5.893593e-01 0.000000e+00

### MMult_1x4_3.c
最内存循环写成一个子函数，一次计算四行一列，并放在一个子函数里面。在**MMult2.c**，每次计算指针的地址都是相对于指针的起点，但是在这里只有第一次是相对于指针的起点，在子函数中，每次的地址偏移都是相对于偏移后的指针，分别是相差[0, 1, 2, 3]行个地址偏移。

40 7.078315e-01 0.000000e+00
80 6.408010e-01 0.000000e+00
120 6.190682e-01 0.000000e+00
160 6.094369e-01 0.000000e+00
200 6.047806e-01 0.000000e+00
240 6.017040e-01 0.000000e+00
280 5.989342e-01 0.000000e+00
320 5.915427e-01 0.000000e+00
360 5.888644e-01 0.000000e+00
400 5.919400e-01 0.000000e+00
440 5.904501e-01 0.000000e+00
480 5.884145e-01 0.000000e+00

### MMult_1x4_4.c
上面的```inline```版本

40 6.983393e-01 0.000000e+00
80 6.345799e-01 0.000000e+00
120 6.160519e-01 0.000000e+00
160 6.018090e-01 0.000000e+00
200 5.949965e-01 0.000000e+00
240 5.917903e-01 0.000000e+00
280 5.866356e-01 0.000000e+00
320 5.824141e-01 0.000000e+00
360 5.828859e-01 0.000000e+00
400 5.821491e-01 0.000000e+00
440 5.788143e-01 0.000000e+00
480 5.740661e-01 0.000000e+00

### MMult_1x4_5.c
将四个for循环合并成一个。

40 1.496341e+00 0.000000e+00
80 1.520793e+00 0.000000e+00
120 1.530106e+00 0.000000e+00
160 1.498091e+00 0.000000e+00
200 1.511394e+00 0.000000e+00
240 1.503058e+00 0.000000e+00
280 1.497259e+00 0.000000e+00
320 1.344291e+00 0.000000e+00
360 1.494598e+00 0.000000e+00
400 1.488700e+00 0.000000e+00
440 1.492487e+00 0.000000e+00
480 1.387479e+00 0.000000e+00

### MMult_1x4_6.c 
使用了关键字``register``，将累加放在寄存器中。注意，在``c++17``中，这个关键字已经废弃。这里使用的是``c++14``。

40 1.945555e+00 0.000000e+00
80 1.970967e+00 0.000000e+00
120 2.009400e+00 0.000000e+00
160 1.997967e+00 0.000000e+00
200 1.966327e+00 0.000000e+00
240 1.964840e+00 0.000000e+00
280 1.990547e+00 0.000000e+00
320 1.642673e+00 0.000000e+00
360 1.980038e+00 0.000000e+00
400 1.993397e+00 0.000000e+00
440 1.984006e+00 0.000000e+00
480 1.772945e+00 0.000000e+00

### MMult_1x4_7.c
元素访问通过指针自身累加的方式实现，而不是每次都在第一个地址上增加偏移。

40 2.128898e+00 0.000000e+00
80 2.209082e+00 0.000000e+00
120 2.218999e+00 0.000000e+00
160 2.190008e+00 0.000000e+00
200 2.142905e+00 0.000000e+00
240 2.145619e+00 0.000000e+00
280 2.152346e+00 0.000000e+00
320 1.775540e+00 0.000000e+00
360 2.137807e+00 0.000000e+00
400 2.141716e+00 0.000000e+00
440 2.141772e+00 0.000000e+00
480 1.904908e+00 0.000000e+00

### MMult_1x4_8.c
进一步展开，每次计算四行中的四列。

40 2.263804e+00 0.000000e+00
80 2.268624e+00 0.000000e+00
120 2.293615e+00 0.000000e+00
160 2.256179e+00 0.000000e+00
200 2.238937e+00 0.000000e+00
240 2.237738e+00 0.000000e+00
280 2.256632e+00 0.000000e+00
320 1.936512e+00 0.000000e+00
360 2.270535e+00 0.000000e+00
400 2.267965e+00 0.000000e+00
440 2.276264e+00 0.000000e+00
480 2.071734e+00 0.000000e+00

### MMult_1x4_9.c
指针不采用自累加方式，性能稍差一点。

40 2.247270e+00 0.000000e+00
80 2.284863e+00 0.000000e+00
120 2.283260e+00 0.000000e+00
160 2.236037e+00 0.000000e+00
200 2.234299e+00 0.000000e+00
240 2.239218e+00 0.000000e+00
280 2.260592e+00 0.000000e+00
320 1.899831e+00 0.000000e+00
360 2.259968e+00 0.000000e+00
400 2.255563e+00 0.000000e+00
440 2.235402e+00 0.000000e+00
480 2.010742e+00 0.000000e+00

### MMult_4x4_3.c
一次计算4x4的块。

40 7.094675e-01 0.000000e+00
80 6.399332e-01 0.000000e+00
120 6.172302e-01 0.000000e+00
160 6.114954e-01 0.000000e+00
200 6.046749e-01 0.000000e+00
240 6.030005e-01 0.000000e+00
280 6.008351e-01 0.000000e+00
320 5.928836e-01 0.000000e+00
360 5.957017e-01 0.000000e+00
400 5.946228e-01 0.000000e+00
440 5.927450e-01 0.000000e+00
480 5.883822e-01 0.000000e+00

### MMult_4x4_4.c
一次计算4x4的块，使用inline，而不是上述的函数调用，性能上基本一致

40 7.028140e-01 0.000000e+00
80 6.373443e-01 0.000000e+00
120 6.178600e-01 0.000000e+00
160 6.042282e-01 0.000000e+00
200 6.045540e-01 0.000000e+00
240 5.987526e-01 0.000000e+00
280 5.948014e-01 0.000000e+00
320 5.890729e-01 0.000000e+00
360 5.957199e-01 0.000000e+00
400 5.902067e-01 0.000000e+00
440 5.886776e-01 0.000000e+00
480 5.882766e-01 0.000000e+00

### MMult_4x4_5.c
将16个计算放在一个循环里面，性能提升显著

40 1.655180e+00 0.000000e+00
80 1.663239e+00 0.000000e+00
120 1.651087e+00 0.000000e+00
160 1.628952e+00 0.000000e+00
200 1.624785e+00 0.000000e+00
240 1.633439e+00 0.000000e+00
280 1.636509e+00 0.000000e+00
320 1.608334e+00 0.000000e+00
360 1.648612e+00 0.000000e+00
400 1.645963e+00 0.000000e+00
440 1.645372e+00 0.000000e+00
480 1.623171e+00 0.000000e+00

### MMult_4x4_6.c
在上面基础上使用了寄存器

40 2.428474e+00 0.000000e+00
80 2.455883e+00 0.000000e+00
120 2.437306e+00 0.000000e+00
160 2.385064e+00 0.000000e+00
200 2.362524e+00 0.000000e+00
240 2.350163e+00 0.000000e+00
280 2.348388e+00 0.000000e+00
320 2.247154e+00 0.000000e+00
360 2.369302e+00 0.000000e+00
400 2.374904e+00 0.000000e+00
440 2.376033e+00 0.000000e+00
480 2.308397e+00 0.000000e+00

### MMult_4x4_7.c
使用了指针

40 2.675921e+00 0.000000e+00
80 2.716180e+00 0.000000e+00
120 2.697806e+00 0.000000e+00
160 2.622560e+00 0.000000e+00
200 2.600798e+00 0.000000e+00
240 2.609666e+00 0.000000e+00
280 2.607494e+00 0.000000e+00
320 2.443345e+00 0.000000e+00
360 2.614944e+00 0.000000e+00
400 2.609697e+00 0.000000e+00
440 2.614179e+00 0.000000e+00
480 2.512204e+00 0.000000e+00

### MMult_4x4_8.c
使用了更多的寄存器，官方的benchmark相对于上一个版本反而下降了，可能是机器的原因。在这里我取得了最好的效果。

40 3.176809e+00 0.000000e+00
80 3.220551e+00 0.000000e+00
120 3.177566e+00 0.000000e+00
160 3.091029e+00 0.000000e+00
200 2.988350e+00 0.000000e+00
240 3.009361e+00 0.000000e+00
280 3.016688e+00 0.000000e+00
320 2.757021e+00 0.000000e+00
360 3.046363e+00 0.000000e+00
400 3.045438e+00 0.000000e+00
440 3.038935e+00 0.000000e+00
480 2.895946e+00 0.000000e+00

### MMult_4x4_9.c
交换了计算顺序，差别不大。

40 3.176809e+00 0.000000e+00
80 3.191682e+00 0.000000e+00
120 3.186355e+00 0.000000e+00
160 3.072000e+00 0.000000e+00
200 3.032720e+00 0.000000e+00
240 3.021488e+00 0.000000e+00
280 3.029708e+00 0.000000e+00
320 2.757301e+00 0.000000e+00
360 3.036635e+00 0.000000e+00
400 3.020043e+00 0.000000e+00
440 3.032008e+00 0.000000e+00
480 2.868919e+00 0.000000e+00

### MMult_4x4_10.c
使用了instric。理论上计算速度得到很大的提升，实际上却慢了很多，不知道是不是arm平台对此并行计算支持不太好。

40 2.329051e+00 0.000000e+00
80 2.302200e+00 0.000000e+00
120 2.223878e+00 0.000000e+00
160 2.313525e+00 0.000000e+00
200 2.240792e+00 0.000000e+00
240 2.257509e+00 0.000000e+00
280 2.255714e+00 0.000000e+00
320 2.130100e+00 0.000000e+00
360 2.266766e+00 0.000000e+00
400 2.280314e+00 0.000000e+00
440 2.272191e+00 0.000000e+00
480 2.183286e+00 0.000000e+00

## 指令集和头文件

|header|isa|
|---|---|
|<mmintrin.h> |MMX|
|<xmmintrin.h>| SSE|
|<emmintrin.h>| SSE2|
|<pmmintrin.h>| SSE3|
|<tmmintrin.h>| SSSE3|
|<smmintrin.h>| SSE4.1|
|<nmmintrin.h>| SSE4.2|
|<ammintrin.h>| SSE4A|
|<wmmintrin.h>| AES|
|<immintrin.h>| AVX, AVX2, FMA|

## Intel / ARM intrinsics equivalence

|SSE             |ARM| Explaination|
|---|---|---|
|__m128          |float32x4_t     |4 x 32 bits floats in a vector|
|_mm_load_ps     |vld1q_f32       |load float vector from memory|
|_mm_store_ps    |vst1q_f32       |store float vector to memory|
|_mm_add_ps      |vaddq_f32       |add float vectors|