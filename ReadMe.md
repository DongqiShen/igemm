# Optimize GEMM step by step


## Result

### MMult0.c

40 6.141563e-01 0.000000e+00
80 5.996341e-01 0.000000e+00
120 5.949347e-01 0.000000e+00
160 5.867897e-01 0.000000e+00
200 5.897105e-01 0.000000e+00
240 5.888551e-01 0.000000e+00
280 5.878294e-01 0.000000e+00
320 5.834000e-01 0.000000e+00
360 5.859244e-01 0.000000e+00
400 5.869953e-01 0.000000e+00
440 5.847044e-01 0.000000e+00
480 5.841649e-01 0.000000e+00

### MMult1.c
将最内层循环写成一个子函数

40 7.063706e-01 0.000000e+00
80 6.398668e-01 0.000000e+00
120 6.211964e-01 0.000000e+00
160 6.087576e-01 0.000000e+00
200 6.046901e-01 0.000000e+00
240 6.028132e-01 0.000000e+00
280 5.998736e-01 0.000000e+00
320 5.843010e-01 0.000000e+00
360 5.959986e-01 0.000000e+00
400 5.948869e-01 0.000000e+00
440 5.930018e-01 0.000000e+00
480 5.902639e-01 0.000000e+00

### MMult2.c
最内存循环写成一个子函数，并且一次计算四行一列

40 6.994536e-01 0.000000e+00
80 6.418723e-01 0.000000e+00
120 6.195769e-01 0.000000e+00
160 6.095786e-01 0.000000e+00
200 6.047892e-01 0.000000e+00
240 6.031545e-01 0.000000e+00
280 6.005458e-01 0.000000e+00
320 5.917278e-01 0.000000e+00
360 5.961168e-01 0.000000e+00
400 5.922830e-01 0.000000e+00
440 5.918232e-01 0.000000e+00
480 5.893593e-01 0.000000e+00

### MMult_1x4_3.c
最内存循环写成一个子函数，一次计算四行一列，并放在一个子函数里面。在**MMult2.c**，每次计算指针的地址都是相对于指针的起点，但是在这里只有第一次是相对于指针的起点，在子函数中，每次的地址偏移都是相对于偏移后的指针，分别是相差[0, 1, 2, 3]行个地址偏移。

40 7.078315e-01 0.000000e+00
80 6.408010e-01 0.000000e+00
120 6.190682e-01 0.000000e+00
160 6.094369e-01 0.000000e+00
200 6.047806e-01 0.000000e+00
240 6.017040e-01 0.000000e+00
280 5.989342e-01 0.000000e+00
320 5.915427e-01 0.000000e+00
360 5.888644e-01 0.000000e+00
400 5.919400e-01 0.000000e+00
440 5.904501e-01 0.000000e+00
480 5.884145e-01 0.000000e+00